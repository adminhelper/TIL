# 1. DTO(Data Transfer Object)

### DTO (Data Transfer Object) 란

DTO는 Data Transfer Object의 약자입니다. 소프트웨어 개발에서, DTO는 다른 계층간에 데이터를 전송하는데 사용되는 객체입니다. 일반적으로, DTO는 순수한 데이터 클래스로, 데이터를 저장하고 전달하는 목적으로만 사용됩니다. 로직이나 동작은 포함하지 않습니다. 아주 단순하게 보면 setter와 getter로만 이뤄집니다.

DTO의 주요 목적은 서로 다른 시스템 컴포넌트간에 데이터를 효율적으로 전달하는 것입니다. 예를 들어, 클라이언트와 서버 간에 데이터를 주고받을 때, 데이터베이스에서 조회한 결과를 비즈니스 로직에 전달할 때 등에 사용됩니다.&#x20;

**캡슐화**: DTO는 데이터를 캡슐화하여 응용 프로그램의 다른 부분에서 해당 데이터에 대한 액세스를 통제합니다.

**결합도 감소**: DTO를 사용하면 서로 다른 시스템 컴포넌트간의 결합도를 낮출 수 있습니다.

**네트워크 효율**: DTO는 네트워크를 통해 전송되기에 적합한 형식으로 데이터를 직렬화하고 역직렬화할 수 있습니다.

**유지 보수 용이성**: 데이터 구조의 변경이 발생하더라도, DTO를 사용하면 영향을 받는 시스템의 범위를 최소화할 수 있습니다.

#### 프로세스 간 통신(IPC, Inter-Process Communication)

독립적인 프로세스들이 서로 정보를 주고받기 위한 메커니즘이나 프로토콜을 말합니다. 프로세스는 컴퓨터 시스템에서 실행되는 독립적인 프로그램 단위로, 각 프로세스는 자체의 메모리 공간과 시스템 자원을 가지고 있습니다. 프로세스 간 통신은 이러한 프로세스들이 상호 작용하고 정보를 공유할 수 있게 해줍니다.

#### IPC 기술

**파일**: 프로세스들이 공유 파일을 사용하여 데이터를 읽고 쓸 수 있습니다. 이 방법은 비교적 간단하지만, 동기화와 성능 문제가 발생할 수 있습니다.

**파이프**: 한 프로세스의 출력이 다른 프로세스의 입력으로 사용되는 단방향 통신 방식입니다. 파이프는 두 프로세스 간에 데이터를 전달하는데 사용되며, 보통 버퍼를 사용해 데이터를 임시로 저장합니다.

**소켓**: 소켓은 네트워크를 통해 서로 다른 시스템의 프로세스들이 통신하는데 사용되는 양방향 통신 메커니즘입니다. 소켓은 인터넷 프로토콜(IP) 및 전송 프로토콜(TCP, UDP 등)을 사용하여 데이터를 전송합니다.

**메시지 큐**: 메시지 큐는 프로세스들이 메시지를 전송하고 수신하는데 사용되는 데이터 구조입니다. 메시지 큐는 프로세스 간에 비동기 통신을 지원하며, 프로세스가 독립적으로 실행될 수 있도록 합니다.

**공유 메모리**: 여러 프로세스가 동일한 메모리 영역을 공유하고 접근할 수 있게 하는 메커니즘입니다. 공유 메모리를 사용할 때, 프로세스들은 동기화 문제를 해결하기 위해 세마포어나 뮤텍스와 같은 동기화 기법을 사용해야 합니다.

**원격 프로시저 호출(RPC)**: 원격 프로시저 호출은 한 프로세스가 다른 프로세스의 함수나 메서드를 호출할 수 있게 해주는 통신 방식입니다. RPC는 분산 시스템에서 프로세스들이 마치 로컬 함수를 호출하는 것처럼 원격 함수를 호출할 수 있게 해줍니다. 이를 통해 프로세스 간의 복잡한 통신을 단순화하며, 서로 다른 시스템에서 실행되는 프로세스들이 서로 작업을 요청하고 응답할 수 있게 합니다.

### “무기력한 도메인 모델” 이란 그리고 안티 패턴인 이유

소프트웨어 개발에서 도메인 모델이 단순히 데이터 저장소로 작동하고, 비즈니스 로직이 대부분 서비스 계층에 구현되어 있는 상태를 말합니다. 이러한 구조는 객체 지향 프로그래밍과 도메인 주도 설계(DDD)의 원칙과 상반되는데, 객체 지향 프로그래밍에서는 데이터와 동작을 하나의 객체에 묶어 캡슐화하는 것이 기본 원칙입니다.

1. 캡슐화 위반: 도메인 모델이 비즈니스 로직을 포함하지 않고, 단순히 데이터 저장소로만 작동할 때, 데이터와 관련된 동작이 캡슐화되지 않습니다. 이로 인해 코드 유지 보수가 어려워지고, 버그 발생 가능성이 높아집니다.
2. 코드 중복: 무기력한 도메인 모델에서 비즈니스 로직은 서비스 계층에 구현되는데, 이러한 구조가 코드 중복을 촉진합니다. 비슷한 로직이 여러 서비스 계층에 중복되어 작성되는 경우가 발생할 수 있습니다.
3. 낮은 응집도: 비즈니스 로직이 여러 서비스 계층에 흩어져 있을 때, 코드의 응집도가 낮아집니다. 이로 인해 코드를 이해하고 수정하기 어려워지며, 테스트 작성도 복잡해집니다.
4. 단일 책임 원칙 위반: 서비스 계층에서 비즈니스 로직을 처리하다 보면, 서비스 계층이 너무 많은 책임을 가지게 됩니다. 이는 객체 지향 프로그래밍의 단일 책임 원칙(SRP)을 위반하는 것입니다.

### 자바빈즈(JavaBeans)

JavaBeans는 Java에서 재사용 가능한 소프트웨어 컴포넌트를 만들기 위한 표준입니다. JavaBeans는 데이터 저장 및 접근을 위한 기본 getter와 setter 메소드를 사용하며, 이를 통해 속성, 이벤트 및 메소드를 캡슐화합니다. JavaBeans는 주로 UI 컴포넌트, 데이터 모델, 그리고 비즈니스 로직을 분리하는 데 사용됩니다.

### EJB(Enterprise JavaBeans)

EJB는 Java EE(Java Enterprise Edition)의 서버 측 컴포넌트 모델입니다. EJB는 분산 애플리케이션 개발을 지원하며, 비즈니스 로직, 트랜잭션 관리, 보안 등의 기능을 제공합니다. EJB는 주로 대형 엔터프라이즈 애플리케이션을 개발하는 데 사용되며, 세 가지 유형의 빈을 지원합니다: 세션 빈, 엔티티 빈, 메시지 구동 빈.

### Java의 record

Java 14부터 추가된 record는 간결한 데이터 클래스를 생성할 수 있는 새로운 형태의 클래스입니다. record는 자동으로 생성되는 getter, setter, equals, hashCode, toString 메소드를 제공하며, 주로 데이터 전송 객체(DTO)나 값 객체와 같은 용도로 사용됩니다.

```java
public record javaDTO(String name, int age) {
}
```

### DAO

DAO는 데이터 액세스 로직과 비즈니스 로직을 분리하기 위한 디자인 패턴입니다. DAO는 데이터베이스와의 상호 작용을 캡슐화하며, CRUD(create, read, update, delete) 작업을 수행하는 메소드를 제공합니다.

```java
public interface UserDAO {
    List<User> getAllUsers();
    User getUserById(int id);
    void addUser(User user);
    void updateUser(User user);
    void deleteUser(int id);
}

```

### ORM

객체 관계 매핑(Object-Relational Mapping, ORM)은 객체 지향 프로그래밍(Object-Oriented Programming, OOP) 언어와 관계형 데이터베이스(Relational Database) 간의 데이터를 변환하고 매핑하는 프로그래밍 기법입니다.

ORM은 객체 지향 프로그래밍 언어에서 사용하는 클래스와 관계형 데이터베이스에서 사용하는 테이블 사이의 연결을 맺어줍니다. ORM을 사용하면 데이터베이스의 테이블을 클래스로, 테이블의 레코드를 클래스의 인스턴스로 쉽게 변환할 수 있습니다. 이렇게 함으로써 개발자는 SQL 쿼리를 직접 작성하지 않고도 데이터베이스와 상호작용할 수 있게 됩니다.

**ORM의 장단점**

1. 코드의 재사용성: 객체 지향 프로그래밍에서 중복 코드를 최소화하고 모듈화된 코드를 작성하는 것이 쉬워집니다.
2. 개발 생산성 향상: SQL 쿼리를 작성하지 않아도 되므로 개발자가 더 빠르게 개발할 수 있습니다.
3. 데이터베이스 독립성: 데이터베이스 시스템을 변경해야 할 때 ORM을 사용하면 코드 수정이 최소화되고, 여러 데이터베이스 시스템 간의 이식성이 높아집니다.
4. 코드 가독성: 객체 지향 프로그래밍 언어의 문법을 사용하므로 코드가 더 이해하기 쉽고 가독성이 좋아집니다.
5. 성능 저하: ORM은 데이터베이스와의 상호작용을 추상화하므로, 직접 작성한 SQL 쿼리에 비해 성능이 저하될 수 있습니다.
6. 복잡한 쿼리 처리 어려움: ORM이 지원하는 기능 범위를 벗어나는 복잡한 쿼리의 경우, ORM만으로는 처리하기 어려울 수 있습니다.

대표적인 ORM 라이브러리로는 `Java의 Hibernate, Python의 SQLAlchemy와 Django ORM, Ruby의 ActiveRecord, JavaScript의 Sequelize` 등이 있습니다.
